/* eslint-disable @typescript-eslint/no-explicit-any */
// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../axios

declare module 'soundcloud-downloader/dist/index' {
  import { Transcoding, TrackInfo, User } from 'soundcloud-downloader/dist/info';
  import { FilterPredicateObject } from 'soundcloud-downloader/dist/filter-media';
  import STREAMING_PROTOCOLS from 'soundcloud-downloader/dist/protocols';
  import FORMATS from 'soundcloud-downloader/dist/formats';
  import { SearchOptions } from 'soundcloud-downloader/dist/search';
  import { AxiosInstance } from 'axios';
  import { PaginatedQuery } from 'soundcloud-downloader/dist/util';
  import { GetLikesOptions, Like } from 'soundcloud-downloader/dist/likes';
  export interface SCDLOptions {
    clientID?: string;
    saveClientID?: boolean;
    filePath?: string;
    axiosInstance?: AxiosInstance;
    stripMobilePrefix?: boolean;
    convertFirebaseLinks?: boolean;
  }
  export class SCDL {
    STREAMING_PROTOCOLS: {
      [key: string]: STREAMING_PROTOCOLS;
    };
    FORMATS: {
      [key: string]: FORMATS;
    };
    axios: AxiosInstance;
    saveClientID: boolean;
    stripMobilePrefix: boolean;
    convertFirebaseLinks: boolean;
    constructor(options?: SCDLOptions);
    /**
     * Returns a media Transcoding that matches the given predicate object
     * @param media - The Transcodings to filter
     * @param predicateObj - The desired Transcoding object to match
     * @returns An array of Transcodings that match the predicate object
     */
    filterMedia(media: Transcoding[], predicateObj: FilterPredicateObject): Transcoding[];
    /**
     * Get the audio of a given track. It returns the first format found.
     *
     * @param url - The URL of the Soundcloud track
     * @param useDirectLink - Whether or not to use the download link if the artist has set the track to be downloadable. This has erratic behaviour on some environments.
     * @returns A ReadableStream containing the audio data
     */
    download(url: string, useDirectLink?: boolean): Promise<any>;
    /**
     *  Get the audio of a given track with the specified format
     * @param url - The URL of the Soundcloud track
     * @param format - The desired format
     */
    downloadFormat(url: string, format: FORMATS): Promise<any>;
    /**
     * Returns info about a given track.
     * @param url - URL of the Soundcloud track
     * @returns Info about the track
     */
    getInfo(url: string): Promise<TrackInfo>;
    /**
     * Returns info about the given track(s) specified by ID.
     * @param ids - The ID(s) of the tracks
     * @returns Info about the track
     */
    getTrackInfoByID(
      ids: number[],
      playlistID?: number,
      playlistSecretToken?: string
    ): Promise<TrackInfo[]>;
    /**
     * Returns info about the given set
     * @param url - URL of the Soundcloud set
     * @returns Info about the set
     */
    getSetInfo(url: string): Promise<import('./info').SetInfo>;
    /**
     * Searches for tracks/playlists for the given query
     * @param options - The search option
     * @returns SearchResponse
     */
    search(options: SearchOptions): Promise<import('./search').SearchResponseAll>;
    /**
     * Finds related tracks to the given track specified by ID
     * @param id - The ID of the track
     * @param limit - The number of results to return
     * @param offset - Used for pagination, set to 0 if you will not use this feature.
     */
    related(
      id: number,
      limit: number,
      offset?: number
    ): Promise<import('./search').RelatedResponse<TrackInfo>>;
    /**
     * Returns the audio streams and titles of the tracks in the given playlist.
     * @param url - The url of the playlist
     */
    downloadPlaylist(url: string): Promise<[ReadableStream<any>[], string[]]>;
    /**
     * Returns track information for a user's likes
     * @param options - Can either be the profile URL of the user, or their ID
     * @returns - An array of tracks
     */
    getLikes(options: GetLikesOptions): Promise<PaginatedQuery<Like>>;
    /**
     * Returns information about a user
     * @param url - The profile URL of the user
     */
    getUser(url: string): Promise<User>;
    /**
     * Sets the instance of Axios to use to make requests to SoundCloud API
     * @param instance - An instance of Axios
     */
    setAxiosInstance(instance: AxiosInstance): void;
    /**
     * Returns whether or not the given URL is a valid Soundcloud URL
     * @param url - URL of the Soundcloud track
     */
    isValidUrl(url: string): boolean;
    /**
     * Returns whether or not the given URL is a valid playlist SoundCloud URL
     * @param url - The URL to check
     */
    isPlaylistURL(url: string): boolean;
    /**
     * Returns true if the given URL is a personalized track URL. (of the form https://soundcloud.com/discover/sets/personalized-tracks::user-sdlkfjsldfljs:847104873)
     * @param url - The URL to check
     */
    isPersonalizedTrackURL(url: string): boolean;
    /**
     * Returns true if the given URL is a Firebase URL (of the form https://soundcloud.app.goo.gl/XXXXXXXX)
     * @param url - The URL to check
     */
    isFirebaseURL(url: string): boolean;
    getClientID(): Promise<string>;
    /** @internal */
    setClientID(clientID?: string): Promise<string>;
    /**
     * Prepares the given URL by stripping its mobile prefix (if this.stripMobilePrefix is true)
     * and converting it to a regular URL (if this.convertFireBaseLinks is true.)
     * @param url
     */
    prepareURL(url: string): Promise<string>;
  }
  const scdl: SCDL;
  const create: (options: SCDLOptions) => SCDL;
  export { create };
  export default scdl;
}

declare module 'soundcloud-downloader/dist/info' {
  import { AxiosInstance } from 'axios';
  import STREAMING_PROTOCOLS from 'soundcloud-downloader/dist/protocols';
  import FORMATS from 'soundcloud-downloader/dist/formats';
  /**
   * A Soundcloud user
   */
  export interface User {
    kind: string;
    avatar_url: string;
    city: string;
    comments_count: number;
    country_code: string;
    created_at: string;
    description: string;
    followers_count: number;
    followings_count: number;
    first_name: string;
    full_name: string;
    groups_count: number;
    id: number;
    last_name: string;
    permalink_url: string;
    uri: string;
    username: string;
  }
  /**
   * Details about the track
   */
  export interface TrackInfo {
    kind: string;
    monetization_model: string;
    id: number;
    policy: string;
    comment_count?: number;
    full_duration?: number;
    downloadable?: false;
    created_at?: string;
    description?: string;
    media?: {
      transcodings: Transcoding[];
    };
    title?: string;
    publisher_metadata?: any;
    duration?: number;
    has_downloads_left?: boolean;
    artwork_url?: string;
    public?: boolean;
    streamable?: true;
    tag_list?: string;
    genre?: string;
    reposts_count?: number;
    label_name?: string;
    state?: string;
    last_modified?: string;
    commentable?: boolean;
    uri?: string;
    download_count?: number;
    likes_count?: number;
    display_date?: string;
    user_id?: number;
    waveform_url?: string;
    permalink?: string;
    permalink_url?: string;
    user?: User;
    playback_count?: number;
  }
  /**
   * Details about a Set
   */
  export interface SetInfo {
    duration: number;
    permalink_url: string;
    reposts_count: number;
    genre: string;
    permalink: string;
    purchase_url?: string;
    description?: string;
    uri: string;
    label_name?: string;
    tag_list: string;
    set_type: string;
    public: boolean;
    track_count: number;
    user_id: number;
    last_modified: string;
    license: string;
    tracks: TrackInfo[];
    id: number;
    release_date?: string;
    display_date: string;
    sharing: string;
    secret_token?: string;
    created_at: string;
    likes_count: number;
    kind: string;
    purchase_title?: string;
    managed_by_feeds: boolean;
    artwork_url?: string;
    is_album: boolean;
    user: User;
    published_at: string;
    embeddable_by: string;
  }
  /**
   * Represents an audio link to a Soundcloud Track
   */
  export interface Transcoding {
    url: string;
    preset: string;
    snipped: boolean;
    format: {
      protocol: STREAMING_PROTOCOLS;
      mime_type: FORMATS;
    };
  }
  /** @internal */
  export const getInfoBase: <T extends TrackInfo | SetInfo>(
    url: string,
    clientID: string,
    axiosRef: AxiosInstance
  ) => Promise<T>;
  /** @internal */
  const getInfo: (
    url: string,
    clientID: string,
    axiosInstance: AxiosInstance
  ) => Promise<TrackInfo>;
  /** @internal */
  export const getSetInfo: (
    url: string,
    clientID: string,
    axiosInstance: AxiosInstance
  ) => Promise<SetInfo>;
  /** @intenral */
  export const getTrackInfoByID: (
    clientID: string,
    axiosInstance: AxiosInstance,
    ids: number[],
    playlistID?: number,
    playlistSecretToken?: string
  ) => Promise<TrackInfo[]>;
  export default getInfo;
}

declare module 'soundcloud-downloader/dist/filter-media' {
  import { Transcoding } from 'soundcloud-downloader/dist/info';
  import FORMATS from 'soundcloud-downloader/dist/formats';
  import STREAMING_PROTOCOLS from 'soundcloud-downloader/dist/protocols';
  export interface FilterPredicateObject {
    protocol?: STREAMING_PROTOCOLS;
    format?: FORMATS;
  }
  /** @internal */
  const filterMedia: (media: Transcoding[], predicateObj: FilterPredicateObject) => Transcoding[];
  export default filterMedia;
}

declare module 'soundcloud-downloader/dist/protocols' {
  /**
   * Soundcloud streams tracks using these protocols.
   */
  enum STREAMING_PROTOCOLS {
    HLS = 'hls',
    PROGRESSIVE = 'progressive'
  }
  /** @internal */
  export const _PROTOCOLS: {
    HLS: STREAMING_PROTOCOLS;
    PROGRESSIVE: STREAMING_PROTOCOLS;
  };
  export default STREAMING_PROTOCOLS;
}

declare module 'soundcloud-downloader/dist/formats' {
  /**
   * Audio formats a track can be encoded in.
   */
  enum FORMATS {
    MP3 = 'audio/mpeg',
    OPUS = 'audio/ogg; codecs="opus"'
  }
  /** @internal */
  export const _FORMATS: {
    MP3: FORMATS;
    OPUS: FORMATS;
  };
  export default FORMATS;
}

declare module 'soundcloud-downloader/dist/search' {
  import { AxiosInstance } from 'axios';
  import { TrackInfo, User, SetInfo } from 'soundcloud-downloader/dist/info';
  import { PaginatedQuery } from 'soundcloud-downloader/dist/util';
  export interface RelatedResponse<T> extends PaginatedQuery<T> {
    variant: string;
  }
  export interface SearchOptions {
    limit?: number;
    offset?: number;
    resourceType?: SoundcloudResource | 'all';
    query?: string;
    nextHref?: string;
  }
  export type SearchResponseAll = PaginatedQuery<User | SetInfo | TrackInfo>;
  export type SoundcloudResource = 'tracks' | 'users' | 'albums' | 'playlists';
  /** @internal */
  export const search: (
    options: SearchOptions,
    axiosInstance: AxiosInstance,
    clientID: string
  ) => Promise<SearchResponseAll>;
  /** @internal */
  export const related: <T extends TrackInfo>(
    id: number,
    limit: number,
    offset: number,
    axiosInstance: AxiosInstance,
    clientID: string
  ) => Promise<RelatedResponse<T>>;
}

declare module 'soundcloud-downloader/dist/util' {
  import { AxiosError } from 'axios';
  export interface PaginatedQuery<T> {
    collection: T[];
    total_results?: number;
    next_href: string;
    query_urn: string;
  }
  export const resolveURL = 'https://api-v2.soundcloud.com/resolve';
  export const handleRequestErrs: (err: AxiosError) => AxiosError<any>;
  export const appendURL: (url: string, ...params: string[]) => string;
  export const extractIDFromPersonalizedTrackURL: (url: string) => string;
  export const kindMismatchError: (expected: string, received: string) => Error;
}

declare module 'soundcloud-downloader/dist/likes' {
  import { AxiosInstance } from 'axios';
  import { TrackInfo } from 'soundcloud-downloader/dist/info';
  import { PaginatedQuery } from 'soundcloud-downloader/dist/util';
  export interface Like {
    created_at: string;
    kind: string;
    track: TrackInfo;
  }
  export interface GetLikesOptions {
    profileUrl?: string;
    id?: number;
    limit?: number;
    offset?: number;
    nextHref?: string;
  }
  /** @internal */
  export const getLikes: (
    options: GetLikesOptions,
    clientID: string,
    axiosInstance: AxiosInstance
  ) => Promise<PaginatedQuery<Like>>;
}
